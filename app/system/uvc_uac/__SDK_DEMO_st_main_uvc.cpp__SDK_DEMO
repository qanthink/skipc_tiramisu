#include <stdio.h>
#include <signal.h>

#include "st_common.h"
#include "st_vpe.h"
#include "st_venc.h"
#include "st_uvc.h"
#include "mi_divp.h"

#define DIVP_INPUT_WIDTH        1920
#define DIVP_INPUT_HEIGHT        1080

unsigned int g_device_num = 1;
#define EINVAL 100

#define USB_CAMERA0_INDEX          0
#define UVC_STREAM0                "uvc_stream0"
#define MAX_UVC_DEV_NUM             1

#ifdef ALIGN_UP
#undef ALIGN_UP
#define ALIGN_UP(x, align) (((x) + ((align) - 1)) & ~((align) - 1))
#else
#define ALIGN_UP(x, align) (((x) + ((align) - 1)) & ~((align) - 1))
#endif
#ifndef ALIGN_DOWN
#define ALIGN_DOWN(val, alignment) (((val)/(alignment))*(alignment))
#endif

struct ST_Stream_Attr_T
{
    MI_BOOL        bEnable;
    ST_Sys_Input_E enInput;
    MI_U32     u32InputChn;
    MI_U32     u32InputPort;
    MI_S32     vencChn;
    MI_VENC_ModType_e eType;
    float      f32Mbps;
    MI_U32     u32Width;
    MI_U32     u32Height;

    MI_U32 enFunc;
    const char    *pszStreamName;
    MI_SYS_BindType_e eBindType;
    MI_U32 u32BindPara;

    MI_BOOL bForceIdr;
    MI_U32 divpChn;
    MI_BOOL bUserVenc;
};

typedef struct
{
    MI_S32 s32UseOnvif;     //0:not use, else use
    MI_S32 s32UseVdf;         // 0: not use, else use
    MI_S32 s32LoadIQ;        // 0: not load, else load IQ file
    MI_S32 s32HDRtype;
    ST_Sensor_Type_T enSensorType;
    MI_SYS_Rotate_e enRotation;
    MI_VPE_3DNR_Level_e en3dNrLevel;
    MI_U8 u8SnrPad;
    MI_S8 s8SnrResIndex;
} ST_Config_S;

typedef struct {
    MI_U32  fcc;
    MI_U32  u32Width;
    MI_U32  u32Height;
    MI_U32  u32FrameRate;
    MI_SYS_ChnPort_t dstChnPort;
} ST_UvcSetting_Attr_T;

typedef struct VENC_STREAMS_s {
    bool used;
    MI_VENC_Stream_t stStream;
} VENC_STREAMS_t;

typedef struct {
    VENC_STREAMS_t *pstuserptr_stream;
} ST_Uvc_Resource_t;

typedef struct {
    char name[20];
    int dev_index;
    ST_UVC_Handle_h handle;
    ST_UvcSetting_Attr_T setting;
    ST_Uvc_Resource_t res;
} ST_UvcDev_t;

typedef struct {
    int devnum;
    ST_UvcDev_t dev[];
} ST_UvcSrc_t;

static MI_BOOL g_bExit = FALSE;
static ST_Config_S g_stConfig;
static ST_UvcSrc_t * g_UvcSrc;
static MI_U8 g_bitrate[MAX_UVC_DEV_NUM] = {0};
static MI_U8 g_qfactor[MAX_UVC_DEV_NUM] = {0};
static MI_U8 g_maxbuf_cnt = 3;

static struct ST_Stream_Attr_T g_stStreamAttr[] =
{
    [USB_CAMERA0_INDEX] =
    {
        //.bEnable = FALSE,
        .bEnable = TRUE,
        .enInput = ST_Sys_Input_VPE,
        .u32InputChn = 0,
        .u32InputPort = 0,
        .vencChn = 0,
        .eType = E_MI_VENC_MODTYPE_H265E,
        .f32Mbps = 2.0,
        .u32Width = 1920,
        .u32Height = 1080,
        .enFunc = ST_Sys_Func_UVC,
        .pszStreamName = UVC_STREAM0,
        .eBindType = E_MI_SYS_BIND_TYPE_REALTIME,
        .u32BindPara = 0,
        .bForceIdr = 0,
    },
};

MI_S32 ST_VideoModuleInit(ST_Config_S* pstConfig)
{
    MI_U32 u32CapWidth = 0, u32CapHeight = 0;
    MI_VIF_FrameRate_e eFrameRate = E_MI_VIF_FRAMERATE_FULL;
    MI_SYS_PixelFormat_e ePixFormat;
    ST_VPE_ChannelInfo_T stVpeChannelInfo;
    ST_Sys_BindInfo_T stBindInfo;
    MI_SNR_PADInfo_t  stPad0Info;
    MI_SNR_PlaneInfo_t stSnrPlane0Info;
    MI_VIF_WorkMode_e eVifWorkMode = E_MI_VIF_WORK_MODE_RGB_REALTIME;
    MI_VIF_HDRType_e eVifHdrType = E_MI_VIF_HDR_TYPE_OFF;
    MI_U32 u32ResCount =0;
    MI_U8 u8ResIndex =0;
    MI_SNR_Res_t stRes;
    MI_U32 u32ChocieRes =0;

    memset(&stPad0Info, 0x0, sizeof(MI_SNR_PADInfo_t));
    memset(&stSnrPlane0Info, 0x0, sizeof(MI_SNR_PlaneInfo_t));
    memset(&stRes, 0x0, sizeof(MI_SNR_Res_t));

    MI_SNR_PAD_ID_e      ePADId = (MI_SNR_PAD_ID_e)pstConfig->u8SnrPad;

    ST_DBG("Snr pad id:%d\n", (int)ePADId);

    if(pstConfig->s32HDRtype > 0)
        MI_SNR_SetPlaneMode(ePADId, TRUE);
    else
        MI_SNR_SetPlaneMode(ePADId, FALSE);

    MI_SNR_QueryResCount(ePADId, &u32ResCount);
    for(u8ResIndex=0; u8ResIndex < u32ResCount; u8ResIndex++)
    {
        MI_SNR_GetRes(ePADId, u8ResIndex, &stRes);
        printf("index %d, Crop(%d,%d,%d,%d), outputsize(%d,%d), maxfps %d, minfps %d, ResDesc %s\n",
        u8ResIndex,
        stRes.stCropRect.u16X, stRes.stCropRect.u16Y, stRes.stCropRect.u16Width,stRes.stCropRect.u16Height,
        stRes.stOutputSize.u16Width, stRes.stOutputSize.u16Height,
        stRes.u32MaxFps,stRes.u32MinFps,
        stRes.strResDesc);
    }

    MI_S8 s8SnrResIndex = pstConfig->s8SnrResIndex;

    if(s8SnrResIndex < 0)
    {
		u32ChocieRes = 0;
    }
    printf("You select %d res\n", u32ChocieRes);

    MI_SNR_SetRes(ePADId,u32ChocieRes);
    MI_SNR_Enable(ePADId);

    MI_SNR_GetPadInfo(ePADId, &stPad0Info);
    MI_SNR_GetPlaneInfo(ePADId, 0, &stSnrPlane0Info);

    u32CapWidth = stSnrPlane0Info.stCapRect.u16Width;
    u32CapHeight = stSnrPlane0Info.stCapRect.u16Height;
    eFrameRate = E_MI_VIF_FRAMERATE_FULL;
    ePixFormat = (MI_SYS_PixelFormat_e)RGB_BAYER_PIXEL(stSnrPlane0Info.ePixPrecision, stSnrPlane0Info.eBayerId);

    if(ePADId == E_MI_SNR_PAD_ID_1)
    {
        //Bind vif dev 0 to sensor pad 1, because only vif dev0 can use realtime mode.
        MI_VIF_Dev2SnrPadMuxCfg_t stDev2SnrPad[3];
        stDev2SnrPad[0].eSensorPadID = E_MI_VIF_SNRPAD_ID_1;
        stDev2SnrPad[0].u32PlaneID = 0xff;
        stDev2SnrPad[1].eSensorPadID = E_MI_VIF_SNRPAD_ID_2;
        stDev2SnrPad[1].u32PlaneID = 0xff;
        stDev2SnrPad[2].eSensorPadID = E_MI_VIF_SNRPAD_ID_0;
        stDev2SnrPad[2].u32PlaneID = 0xff;
        MI_VIF_SetDev2SnrPadMux(stDev2SnrPad, 3);
    }

    eVifHdrType = (MI_VIF_HDRType_e)pstConfig->s32HDRtype;

    STCHECKRESULT(ST_Vif_EnableDev(0, eVifWorkMode, eVifHdrType, &stPad0Info));

    ST_VIF_PortInfo_T stVifPortInfoInfo;
    memset(&stVifPortInfoInfo, 0, sizeof(ST_VIF_PortInfo_T));
    stVifPortInfoInfo.u32RectX = stRes.stCropRect.u16X;
    stVifPortInfoInfo.u32RectY = stRes.stCropRect.u16Y;
    stVifPortInfoInfo.u32RectWidth = u32CapWidth;
    stVifPortInfoInfo.u32RectHeight = u32CapHeight;
    stVifPortInfoInfo.u32DestWidth = u32CapWidth;
    stVifPortInfoInfo.u32DestHeight = u32CapHeight;
    stVifPortInfoInfo.eFrameRate = eFrameRate;
    stVifPortInfoInfo.ePixFormat = ePixFormat;
    STCHECKRESULT(ST_Vif_CreatePort(0, 0, &stVifPortInfoInfo));
    STCHECKRESULT(ST_Vif_StartPort(0, 0, 0));
    {
        MI_BOOL bMirror = FALSE, bFlip = FALSE;
        MI_SNR_SetOrien(ePADId, bMirror, bFlip);
        MI_VPE_SetChannelRotation(0, pstConfig->enRotation);
    }

    //for (unsigned int i = 0; i < g_device_num;i++)
    for (unsigned int i = 0; i < 1; i++)
    {
        ST_Stream_Attr_T *pstStreamAttr = &g_stStreamAttr[i];

        memset(&stVpeChannelInfo, 0, sizeof(ST_VPE_ChannelInfo_T));
        memset(&stBindInfo, 0x0, sizeof(ST_Sys_BindInfo_T));

        stVpeChannelInfo.u16VpeMaxW = u32CapWidth;
        stVpeChannelInfo.u16VpeMaxH = u32CapHeight;
        stVpeChannelInfo.u32X = 0;
        stVpeChannelInfo.u32Y = 0;
        stVpeChannelInfo.u16VpeCropW = 0;
        stVpeChannelInfo.u16VpeCropH = 0;

            stBindInfo.eBindType = E_MI_SYS_BIND_TYPE_REALTIME;
            stVpeChannelInfo.eRunningMode = E_MI_VPE_RUN_REALTIME_MODE;
        stVpeChannelInfo.eFormat = ePixFormat;
        stVpeChannelInfo.e3DNRLevel = pstConfig->en3dNrLevel;
        stVpeChannelInfo.eHDRtype = (MI_VPE_HDRType_e)pstConfig->s32HDRtype;
        stVpeChannelInfo.bRotation = FALSE;
        stVpeChannelInfo.eBindSensorId = (MI_VPE_SensorChannel_e)(ePADId + 1);

            stVpeChannelInfo.bEnableLdc = FALSE;
            /* crop vpe channel need set zoom mode */
            stVpeChannelInfo.u32ChnPortMode = E_MI_VPE_ZOOM_LDC_NULL;

        STCHECKRESULT(ST_Vpe_CreateChannel(pstStreamAttr->u32InputChn, &stVpeChannelInfo));

        //LDC Flow

        STCHECKRESULT(ST_Vpe_StartChannel(pstStreamAttr->u32InputChn));

        stBindInfo.stSrcChnPort.eModId = E_MI_MODULE_ID_VIF;
        stBindInfo.stSrcChnPort.u32DevId = 0;
        stBindInfo.stSrcChnPort.u32ChnId = 0;
        stBindInfo.stSrcChnPort.u32PortId = 0;
        stBindInfo.stDstChnPort.eModId = E_MI_MODULE_ID_VPE;
        stBindInfo.stDstChnPort.u32DevId = 0;
        stBindInfo.stDstChnPort.u32ChnId = pstStreamAttr->u32InputChn;
        stBindInfo.stDstChnPort.u32PortId = pstStreamAttr->u32InputPort;
        stBindInfo.u32SrcFrmrate = 30;
        stBindInfo.u32DstFrmrate = 30;
        STCHECKRESULT(ST_Sys_Bind(&stBindInfo));
    }

    return MI_SUCCESS;
}

MI_S32 ST_VideoModuleUnInit(ST_Config_S* pstConfig)
{
    MI_SNR_PAD_ID_e      ePADId = (MI_SNR_PAD_ID_e)pstConfig->u8SnrPad;
    ST_Sys_BindInfo_T stBindInfo;

    memset(&stBindInfo, 0x0, sizeof(ST_Sys_BindInfo_T));
    stBindInfo.stSrcChnPort.eModId = E_MI_MODULE_ID_VIF;
    stBindInfo.stSrcChnPort.u32DevId = 0;
    stBindInfo.stSrcChnPort.u32ChnId = 0;
    stBindInfo.stSrcChnPort.u32PortId = 0;

    stBindInfo.stDstChnPort.eModId = E_MI_MODULE_ID_VPE;
    stBindInfo.stDstChnPort.u32DevId = 0;
    stBindInfo.stDstChnPort.u32ChnId = 0;
    stBindInfo.stDstChnPort.u32PortId = 0;

    stBindInfo.u32SrcFrmrate = 30;
    stBindInfo.u32DstFrmrate = 30;
    STCHECKRESULT(ST_Sys_UnBind(&stBindInfo));

    STCHECKRESULT(ST_Vpe_StopChannel(0));
    STCHECKRESULT(ST_Vpe_DestroyChannel(0));

    STCHECKRESULT(ST_Vif_StopPort(0, 0));
    STCHECKRESULT(ST_Vif_DisableDev(0));
    STCHECKRESULT(MI_SNR_Disable(ePADId));

    return MI_SUCCESS;
}

void ST_DefaultConfig(ST_Config_S *pstConfig)
{
    pstConfig->s32UseOnvif     = 0;
    pstConfig->s32UseVdf    = 0;
    pstConfig->s32LoadIQ    = 0;
    pstConfig->s32HDRtype    = 0;
    pstConfig->enSensorType = ST_Sensor_Type_IMX291;
    pstConfig->enRotation = E_MI_SYS_ROTATE_NONE;
}

void ST_DefaultArgs(ST_Config_S *pstConfig)
{
    memset(pstConfig, 0, sizeof(ST_Config_S));
    ST_DefaultConfig(pstConfig);

    pstConfig->s32UseOnvif = 0;
    pstConfig->s32UseVdf = 0;
    pstConfig->s32LoadIQ = 0;
    pstConfig->enRotation = E_MI_SYS_ROTATE_NONE;
    pstConfig->en3dNrLevel = E_MI_VPE_3DNR_LEVEL1;
    pstConfig->s8SnrResIndex = -1;
}

void ST_HandleSig(MI_S32 signo)
{
    if(signo == SIGINT)
    {
        ST_INFO("catch Ctrl + C, exit normally\n");

        g_bExit = TRUE;
    }
}

static MI_S32 UVC_Init(void *uvc)
{
    return MI_SUCCESS;
}

static MI_S32 UVC_Deinit(void *uvc)
{
    return MI_SUCCESS;
}

static ST_UvcDev_t * Get_UVC_Device(void *uvc)
{
    ST_UVC_Device_t *pdev = (ST_UVC_Device_t*)uvc;

    for (int i = 0; i < g_UvcSrc->devnum;i++)
    {
        ST_UvcDev_t *dev = &g_UvcSrc->dev[i];
        if (!strcmp(dev->name, pdev->name))
        {
            return dev;
        }
    }
    return NULL;
}

static void UVC_ForceIdr(void *uvc)
{
}

static MI_S32 UVC_MM_FillBuffer(void *uvc,ST_UVC_BufInfo_t *bufInfo)
{
    ST_UvcDev_t * dev = Get_UVC_Device(uvc);
    ST_Stream_Attr_T *pstStreamAttr = g_stStreamAttr;
    MI_S32 s32Ret = MI_SUCCESS;
    MI_U32 u32Size, i;
    MI_SYS_BufInfo_t stBufInfo;
    MI_SYS_BUF_HANDLE stBufHandle;
    MI_SYS_ChnPort_t dstChnPort;
    MI_VENC_Stream_t stStream;
    MI_VENC_Pack_t stPack[4];
    MI_VENC_ChnStat_t stStat;

    MI_U8 *u8CopyData = (MI_U8 *)bufInfo->b.buf;
    MI_U32 *pu32length = (MI_U32 *)&bufInfo->length;
    MI_U32 VencChn = pstStreamAttr[dev->dev_index].vencChn;

    if (!dev)
        return -1;

    dstChnPort = dev->setting.dstChnPort;

    switch(dev->setting.fcc) {
        case V4L2_PIX_FMT_YUYV:
            memset(&stBufInfo, 0, sizeof(MI_SYS_BufInfo_t));
            memset(&stBufHandle, 0, sizeof(MI_SYS_BUF_HANDLE));

            s32Ret = MI_SYS_ChnOutputPortGetBuf(&dstChnPort, &stBufInfo, &stBufHandle);
            if(MI_SUCCESS!=s32Ret)
            {
                return -EINVAL;
            }

            *pu32length = stBufInfo.stFrameData.u16Height * stBufInfo.stFrameData.u32Stride[0];
            memcpy(u8CopyData, stBufInfo.stFrameData.pVirAddr[0], *pu32length);

            s32Ret = MI_SYS_ChnOutputPortPutBuf(stBufHandle);
            if(MI_SUCCESS!=s32Ret)
                printf("%s Release Frame Failed\n", __func__);

            break;
        case V4L2_PIX_FMT_MJPEG:
        case V4L2_PIX_FMT_H264:
        case V4L2_PIX_FMT_H265:
            memset(&stStream, 0, sizeof(MI_VENC_Stream_t));
            memset(&stPack, 0, sizeof(MI_VENC_Pack_t) * 4);
            stStream.pstPack = stPack;

            s32Ret = MI_VENC_Query(VencChn, &stStat);
            if(s32Ret != MI_SUCCESS || stStat.u32CurPacks == 0)
                return -EINVAL;

            stStream.u32PackCount = stStat.u32CurPacks;

            s32Ret = MI_VENC_GetStream(VencChn, &stStream, 40);
            if (MI_SUCCESS != s32Ret)
                return -EINVAL;
            if (((dev->setting.fcc == V4L2_PIX_FMT_H264) && (stStream.stH264Info.eRefType == E_MI_VENC_BASE_IDR)) ||
                ((dev->setting.fcc == V4L2_PIX_FMT_H265) && (stStream.stH265Info.eRefType == E_MI_VENC_BASE_IDR))) {
                bufInfo->is_keyframe = true;
            }
            else {
                bufInfo->is_keyframe = false;
            }

            for(i = 0;i < stStat.u32CurPacks; i++)
            {
                u32Size = stStream.pstPack[i].u32Len;
                memcpy(u8CopyData,stStream.pstPack[i].pu8Addr, u32Size);
                u8CopyData += u32Size;
            }
            *pu32length = u8CopyData - (MI_U8 *)bufInfo->b.buf;


            bufInfo->is_tail = true;//default is frameEnd
            s32Ret = MI_VENC_ReleaseStream(VencChn, &stStream);
            if (MI_SUCCESS != s32Ret)
                printf("%s Release Frame Failed\n", __func__);

            if (pstStreamAttr[dev->dev_index].bForceIdr)
            {
                pstStreamAttr[dev->dev_index].bForceIdr = FALSE;
                MI_VENC_RequestIdr(VencChn, TRUE);
            }
            break;
        default:
            printf("unknown format %d\n", dev->setting.fcc);
            return -EINVAL;
    }

    return MI_SUCCESS;
}

static MI_S32 UVC_StartCapture(void *uvc,Stream_Params_t format)
{
    ST_UvcDev_t *dev = Get_UVC_Device(uvc);
    ST_Stream_Attr_T *pstStreamAttr;
    MI_SYS_ChnPort_t *dstChnPort;
    ST_Sys_BindInfo_T stBindInfo[2];
    MI_U32 u32Width, u32Height;

    /************************************************
    Step0:  Initial general param
    *************************************************/
    if (!dev)
        return -1;

    memset(&dev->setting, 0x00, sizeof(dev->setting));
    dev->setting.fcc = format.fcc;
    dev->setting.u32Width = format.width;
    dev->setting.u32Height = format.height;
    dev->setting.u32FrameRate = format.frameRate;

    dstChnPort = &dev->setting.dstChnPort;
    pstStreamAttr = g_stStreamAttr;
    u32Width = dev->setting.u32Width;
    u32Height = dev->setting.u32Height;

    /************************************************
    Step1:  start VPE port
    *************************************************/
    MI_U32 VpeChn = pstStreamAttr[dev->dev_index].u32InputChn;
    MI_U32 VpePortId = pstStreamAttr[dev->dev_index].u32InputPort;
    ST_VPE_PortInfo_T stVpePortInfo;

    stVpePortInfo.DepVpeChannel   = VpeChn;
    pstStreamAttr[dev->dev_index].bEnable = TRUE;
    pstStreamAttr[dev->dev_index].bUserVenc = FALSE;
    pstStreamAttr[dev->dev_index].u32Width = u32Width;
    pstStreamAttr[dev->dev_index].u32Height = u32Height;
    if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_VPE)
    {
        stVpePortInfo.u16OutputWidth  = u32Width;
        stVpePortInfo.u16OutputHeight = u32Height;
    }
    else if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_DIVP)
    {
        stVpePortInfo.u16OutputWidth  = DIVP_INPUT_WIDTH;
        stVpePortInfo.u16OutputHeight = DIVP_INPUT_HEIGHT;
    }

    stVpePortInfo.eCompressMode = E_MI_SYS_COMPRESS_MODE_NONE;

    /************************************************
    Step2: Init Divp Option
    ************************************************/
    MI_DIVP_CHN DivpChn = pstStreamAttr[dev->dev_index].divpChn;
    MI_DIVP_ChnAttr_t stDivpChnAttr;
    MI_DIVP_OutputPortAttr_t stDivpOutputPortAttr;
    memset(&stDivpChnAttr,0,sizeof(MI_DIVP_ChnAttr_t));
    memset(&stDivpOutputPortAttr,0,sizeof(MI_DIVP_OutputPortAttr_t));

    stDivpChnAttr.u32MaxWidth = DIVP_INPUT_WIDTH;
    stDivpChnAttr.u32MaxHeight = DIVP_INPUT_HEIGHT;
    stDivpChnAttr.stCropRect.u16X = 0;
    stDivpChnAttr.stCropRect.u16Y = 0;
    stDivpChnAttr.stCropRect.u16Width = DIVP_INPUT_WIDTH;
    stDivpChnAttr.stCropRect.u16Height = DIVP_INPUT_HEIGHT;
    stDivpChnAttr.bHorMirror = false;
    stDivpChnAttr.bVerMirror = false;
    stDivpChnAttr.eDiType = E_MI_DIVP_DI_TYPE_OFF;
    stDivpChnAttr.eRotateType = E_MI_SYS_ROTATE_NONE;
    stDivpChnAttr.eTnrLevel = E_MI_DIVP_TNR_LEVEL_OFF;

    stDivpOutputPortAttr.eCompMode = E_MI_SYS_COMPRESS_MODE_NONE;
    //stDivpOutputPortAttr.ePixelFormat = E_MI_SYS_PIXEL_FRAME_YUV_SEMIPLANAR_420;
    stDivpOutputPortAttr.u32Width = u32Width;
    stDivpOutputPortAttr.u32Height = u32Height;

    /************************************************
    Step3: Init Venc Option
    ************************************************/
    MI_U32 VencChn = pstStreamAttr[dev->dev_index].vencChn;
    MI_U32 u32FrameRate = 0;
    MI_VENC_ChnAttr_t stChnAttr;
    MI_U32  u32VenBitRate =0;
    MI_U32  u32VenQfactor =80;
    MI_U32 VencDev = 0;
    MI_VENC_InputSourceConfig_t stVenInSrc;
    bool bByFrame = true;
    bool bHaftRing = true;

    memset(&stChnAttr, 0, sizeof(MI_VENC_ChnAttr_t));
    memset(&stVenInSrc, 0, sizeof(MI_VENC_InputSourceConfig_t));

    /************************************************
    Step4: Init Bind Option
    ************************************************/
    if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_VPE)
    {
        memset(&stBindInfo[0], 0x0, sizeof(ST_Sys_BindInfo_T));
        stBindInfo[0].stSrcChnPort.eModId = E_MI_MODULE_ID_VPE;
        stBindInfo[0].stSrcChnPort.u32DevId = 0;
        stBindInfo[0].stSrcChnPort.u32ChnId = VpeChn;
        stBindInfo[0].stSrcChnPort.u32PortId = VpePortId;

        stBindInfo[0].stDstChnPort.eModId = E_MI_MODULE_ID_VENC;
        stBindInfo[0].stDstChnPort.u32ChnId = VencChn;
        stBindInfo[0].stDstChnPort.u32PortId = 0;

        stBindInfo[0].u32SrcFrmrate = dev->setting.u32FrameRate;
        stBindInfo[0].u32DstFrmrate = dev->setting.u32FrameRate;
        u32FrameRate =  dev->setting.u32FrameRate;
    }
    else if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_DIVP)
    {
        memset(&stBindInfo[0], 0x0, sizeof(ST_Sys_BindInfo_T));
        stBindInfo[0].stSrcChnPort.eModId = E_MI_MODULE_ID_VPE;
        stBindInfo[0].stSrcChnPort.u32DevId = 0;
        stBindInfo[0].stSrcChnPort.u32ChnId = VpeChn;
        stBindInfo[0].stSrcChnPort.u32PortId = VpePortId;

        stBindInfo[0].stDstChnPort.eModId = E_MI_MODULE_ID_DIVP;
        stBindInfo[0].stDstChnPort.u32ChnId = DivpChn;
        stBindInfo[0].stDstChnPort.u32PortId = 0;

        stBindInfo[0].u32SrcFrmrate = dev->setting.u32FrameRate;
        stBindInfo[0].u32DstFrmrate = dev->setting.u32FrameRate;

        memset(&stBindInfo[1], 0x0, sizeof(ST_Sys_BindInfo_T));
        stBindInfo[1].stSrcChnPort.eModId = E_MI_MODULE_ID_DIVP;
        stBindInfo[1].stSrcChnPort.u32DevId = 0;
        stBindInfo[1].stSrcChnPort.u32ChnId = DivpChn;
        stBindInfo[1].stSrcChnPort.u32PortId = 0;

        stBindInfo[1].stDstChnPort.eModId = E_MI_MODULE_ID_VENC;
        stBindInfo[1].stDstChnPort.u32ChnId = VencChn;
        stBindInfo[1].stDstChnPort.u32PortId = 0;

        stBindInfo[1].u32SrcFrmrate = dev->setting.u32FrameRate;
        stBindInfo[1].u32DstFrmrate = dev->setting.u32FrameRate;
        u32FrameRate =  dev->setting.u32FrameRate;
    }

    if (u32Width * u32Height >= 1920 *1080)
    {
        u32VenBitRate = 1024 * 1024 * 4;
    }
    else if(u32Width * u32Height < 640*480)
    {
        u32VenBitRate = 1024 * 500;
        /* Use one buffer when resolution than less VGA */
        bHaftRing = false;
    }
    else
    {
        u32VenBitRate = 1024 * 1024 * 2;
    }

    if (g_bitrate[dev->dev_index])
        u32VenBitRate = g_bitrate[dev->dev_index] * 1024 * 1024;

    if (g_qfactor[dev->dev_index])
        u32VenQfactor = g_qfactor[dev->dev_index];

    if (!dev->res.pstuserptr_stream)
    {
        dev->res.pstuserptr_stream = (VENC_STREAMS_t*)calloc(g_maxbuf_cnt, sizeof(VENC_STREAMS_t));
        for(int i=0; i<g_maxbuf_cnt; i++)
        {
            dev->res.pstuserptr_stream[i].stStream.pstPack = (MI_VENC_Pack_t*)calloc(4, sizeof(MI_VENC_Pack_t));
        }
    }

    switch(dev->setting.fcc) {
        case V4L2_PIX_FMT_YUYV:
            stVpePortInfo.ePixelFormat = E_MI_SYS_PIXEL_FRAME_YUV422_YUYV;
            stDivpOutputPortAttr.ePixelFormat = E_MI_SYS_PIXEL_FRAME_YUV422_YUYV;

            if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_DIVP)
            {
                STCHECKRESULT(ST_Vpe_StartPort(VpePortId, &stVpePortInfo));

                STCHECKRESULT(MI_DIVP_CreateChn(DivpChn,&stDivpChnAttr));
                STCHECKRESULT(MI_DIVP_SetOutputPortAttr(DivpChn,&stDivpOutputPortAttr));

                stBindInfo[0].stDstChnPort.u32DevId = 0;
                stBindInfo[0].eBindType = E_MI_SYS_BIND_TYPE_FRAME_BASE;
                stBindInfo[0].u32BindParam = 0;
                STCHECKRESULT(ST_Sys_Bind(&stBindInfo[0]));

                STCHECKRESULT(MI_DIVP_StartChn(DivpChn));

                *dstChnPort = stBindInfo[0].stDstChnPort;
                STCHECKRESULT(MI_SYS_SetChnOutputPortDepth(dstChnPort, g_maxbuf_cnt+1, g_maxbuf_cnt+2));

                break;
            }
            else if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_VPE)
            {
                STCHECKRESULT(ST_Vpe_StartPort(VpePortId, &stVpePortInfo));

                *dstChnPort = stBindInfo[0].stSrcChnPort;
                STCHECKRESULT(MI_SYS_SetChnOutputPortDepth(dstChnPort, g_maxbuf_cnt+1, g_maxbuf_cnt+2));

                break;
            }

        case V4L2_PIX_FMT_MJPEG:
            pstStreamAttr[dev->dev_index].bUserVenc = TRUE;

            stVpePortInfo.ePixelFormat = E_MI_SYS_PIXEL_FRAME_YUV_SEMIPLANAR_420;

            stDivpOutputPortAttr.ePixelFormat = E_MI_SYS_PIXEL_FRAME_YUV_SEMIPLANAR_420;

            stChnAttr.stRcAttr.eRcMode = E_MI_VENC_RC_MODE_MJPEGFIXQP;
            stChnAttr.stRcAttr.stAttrMjpegFixQp.u32SrcFrmRateNum = u32FrameRate;
            stChnAttr.stRcAttr.stAttrMjpegFixQp.u32SrcFrmRateDen = 1;
            stChnAttr.stVeAttr.stAttrJpeg.u32BufSize = ALIGN_UP(u32Width*u32Height*3/4, 16);
            stChnAttr.stVeAttr.stAttrJpeg.u32PicWidth = u32Width;
            stChnAttr.stVeAttr.stAttrJpeg.u32PicHeight = u32Height;
            stChnAttr.stVeAttr.stAttrJpeg.u32MaxPicWidth =  u32Width;
            stChnAttr.stVeAttr.stAttrJpeg.u32MaxPicHeight = ALIGN_UP(u32Height, 16);
            stChnAttr.stVeAttr.stAttrJpeg.bByFrame = true;
            stChnAttr.stVeAttr.eType = E_MI_VENC_MODTYPE_JPEGE;
            stChnAttr.stRcAttr.stAttrMjpegFixQp.u32Qfactor = u32VenQfactor; //default 80, [0~90]

            if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_DIVP)
            {
                STCHECKRESULT(ST_Vpe_StartPort(VpePortId, &stVpePortInfo));

                STCHECKRESULT(MI_DIVP_CreateChn(DivpChn,&stDivpChnAttr));
                STCHECKRESULT(MI_DIVP_SetOutputPortAttr(DivpChn,&stDivpOutputPortAttr));

                stBindInfo[0].stDstChnPort.u32DevId = 0;
                stBindInfo[0].eBindType = E_MI_SYS_BIND_TYPE_FRAME_BASE;
                stBindInfo[0].u32BindParam = 0;
                STCHECKRESULT(ST_Sys_Bind(&stBindInfo[0]));

                STCHECKRESULT(MI_DIVP_StartChn(DivpChn));

                STCHECKRESULT(ST_Venc_CreateChannel(VencChn, &stChnAttr));
                STCHECKRESULT(MI_VENC_GetChnDevid(VencChn, &VencDev));

                stBindInfo[1].stDstChnPort.u32DevId = VencDev;
                pstStreamAttr[dev->dev_index].eBindType = stBindInfo[1].eBindType = E_MI_SYS_BIND_TYPE_FRAME_BASE;
                pstStreamAttr[dev->dev_index].u32BindPara = stBindInfo[1].u32BindParam = 0;
                STCHECKRESULT(ST_Sys_Bind(&stBindInfo[1]));

                STCHECKRESULT(MI_VENC_SetMaxStreamCnt(VencChn, g_maxbuf_cnt+1));
                STCHECKRESULT(ST_Venc_StartChannel(VencChn));
                *dstChnPort = stBindInfo[1].stDstChnPort;

                break;
            }
            else if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_VPE)
            {
                STCHECKRESULT(ST_Vpe_StartPort(VpePortId, &stVpePortInfo));

                STCHECKRESULT(ST_Venc_CreateChannel(VencChn, &stChnAttr));
                STCHECKRESULT(MI_VENC_GetChnDevid(VencChn, &VencDev));

                stBindInfo[0].stDstChnPort.u32DevId = VencDev;

                pstStreamAttr[dev->dev_index].eBindType = stBindInfo[0].eBindType = E_MI_SYS_BIND_TYPE_FRAME_BASE;

                pstStreamAttr[dev->dev_index].u32BindPara = stBindInfo[0].u32BindParam = 0;
                STCHECKRESULT(ST_Sys_Bind(&stBindInfo[0]));

                STCHECKRESULT(MI_VENC_SetMaxStreamCnt(VencChn, g_maxbuf_cnt+1));
                STCHECKRESULT(ST_Venc_StartChannel(VencChn));
                *dstChnPort = stBindInfo[0].stDstChnPort;

                break;
            }

        case V4L2_PIX_FMT_H265:
            pstStreamAttr[dev->dev_index].bUserVenc = TRUE;
            stVpePortInfo.ePixelFormat = E_MI_SYS_PIXEL_FRAME_YUV_SEMIPLANAR_420;
            stDivpOutputPortAttr.ePixelFormat = E_MI_SYS_PIXEL_FRAME_YUV_SEMIPLANAR_420;

            stChnAttr.stVeAttr.stAttrH265e.u32PicWidth = u32Width;
            stChnAttr.stVeAttr.stAttrH265e.u32PicHeight = u32Height;
            stChnAttr.stVeAttr.stAttrH265e.u32MaxPicWidth = u32Width;
            stChnAttr.stVeAttr.stAttrH265e.u32MaxPicHeight = u32Height;
            stChnAttr.stVeAttr.stAttrH265e.bByFrame = bByFrame;
            stChnAttr.stRcAttr.eRcMode = E_MI_VENC_RC_MODE_H265CBR;
            stChnAttr.stRcAttr.stAttrH265Cbr.u32BitRate = u32VenBitRate;
            stChnAttr.stRcAttr.stAttrH265Cbr.u32SrcFrmRateNum = u32FrameRate;
            stChnAttr.stRcAttr.stAttrH265Cbr.u32SrcFrmRateDen = 1;
            stChnAttr.stRcAttr.stAttrH265Cbr.u32Gop = 30;
            stChnAttr.stRcAttr.stAttrH265Cbr.u32FluctuateLevel = 0;
            stChnAttr.stRcAttr.stAttrH265Cbr.u32StatTime = 0;
            stChnAttr.stVeAttr.eType = E_MI_VENC_MODTYPE_H265E;

            if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_DIVP)
            {
                STCHECKRESULT(ST_Vpe_StartPort(VpePortId, &stVpePortInfo));

                STCHECKRESULT(MI_DIVP_CreateChn(DivpChn,&stDivpChnAttr));
                STCHECKRESULT(MI_DIVP_SetOutputPortAttr(DivpChn,&stDivpOutputPortAttr));

                stBindInfo[0].stDstChnPort.u32DevId = 0;
                stBindInfo[0].eBindType = E_MI_SYS_BIND_TYPE_FRAME_BASE;
                stBindInfo[0].u32BindParam = 0;
                STCHECKRESULT(ST_Sys_Bind(&stBindInfo[0]));

                STCHECKRESULT(MI_DIVP_StartChn(DivpChn));

                STCHECKRESULT(ST_Venc_CreateChannel(VencChn, &stChnAttr));
                STCHECKRESULT(MI_VENC_GetChnDevid(VencChn, &VencDev));

                stBindInfo[1].stDstChnPort.u32DevId = VencDev;
                pstStreamAttr[dev->dev_index].eBindType = stBindInfo[1].eBindType = E_MI_SYS_BIND_TYPE_FRAME_BASE;
                pstStreamAttr[dev->dev_index].u32BindPara = stBindInfo[1].u32BindParam = 0;

                if(g_device_num == 1)
                {
                    pstStreamAttr[dev->dev_index].eBindType = stBindInfo[1].eBindType = E_MI_SYS_BIND_TYPE_HW_RING;
                    pstStreamAttr[dev->dev_index].u32BindPara = stBindInfo[1].u32BindParam = bHaftRing ? u32Height/2 : u32Height;
                    if (bHaftRing)
                    {
                        stVenInSrc.eInputSrcBufferMode = E_MI_VENC_INPUT_MODE_RING_HALF_FRM;
                        MI_VENC_SetInputSourceConfig(VencChn, &stVenInSrc);
                    }
                    else
                    {
                        stVenInSrc.eInputSrcBufferMode = E_MI_VENC_INPUT_MODE_RING_ONE_FRM;
                        MI_VENC_SetInputSourceConfig(VencChn, &stVenInSrc);
                    }
                }

                STCHECKRESULT(ST_Sys_Bind(&stBindInfo[1]));

                STCHECKRESULT(MI_VENC_SetMaxStreamCnt(VencChn, g_maxbuf_cnt+1));
                STCHECKRESULT(ST_Venc_StartChannel(VencChn));
                *dstChnPort = stBindInfo[1].stDstChnPort;

                break;
            }
            else if(pstStreamAttr[dev->dev_index].enInput == ST_Sys_Input_VPE)
            {
                STCHECKRESULT(ST_Vpe_StartPort(VpePortId, &stVpePortInfo));

                STCHECKRESULT(ST_Venc_CreateChannel(VencChn, &stChnAttr));
                STCHECKRESULT(MI_VENC_GetChnDevid(VencChn, &VencDev));

                stBindInfo[0].stDstChnPort.u32DevId = VencDev;
                pstStreamAttr[dev->dev_index].eBindType = stBindInfo[0].eBindType = E_MI_SYS_BIND_TYPE_FRAME_BASE;
                pstStreamAttr[dev->dev_index].u32BindPara = stBindInfo[0].u32BindParam = 0;

                if(g_device_num == 1)
                {
                    pstStreamAttr[dev->dev_index].eBindType = stBindInfo[0].eBindType = E_MI_SYS_BIND_TYPE_HW_RING;
                    pstStreamAttr[dev->dev_index].u32BindPara = stBindInfo[0].u32BindParam = bHaftRing ? u32Height/2 : u32Height;
                    if (bHaftRing)
                    {
                        stVenInSrc.eInputSrcBufferMode = E_MI_VENC_INPUT_MODE_RING_HALF_FRM;
                        MI_VENC_SetInputSourceConfig(VencChn, &stVenInSrc);
                    }
                    else
                    {
                        stVenInSrc.eInputSrcBufferMode = E_MI_VENC_INPUT_MODE_RING_ONE_FRM;
                        MI_VENC_SetInputSourceConfig(VencChn, &stVenInSrc);
                    }
                }

                STCHECKRESULT(ST_Sys_Bind(&stBindInfo[0]));

                STCHECKRESULT(MI_VENC_SetMaxStreamCnt(VencChn, g_maxbuf_cnt+1));
                STCHECKRESULT(ST_Venc_StartChannel(VencChn));
                *dstChnPort = stBindInfo[0].stDstChnPort;

                break;
            }

        default:
            return -EINVAL;
    }

    printf("Capture u32Width: %d, u32height: %d, format: %s\n",u32Width,u32Height,
        dev->setting.fcc==V4L2_PIX_FMT_YUYV ? "YUYV":(dev->setting.fcc==V4L2_PIX_FMT_NV12 ? "NV12":
        (dev->setting.fcc==V4L2_PIX_FMT_MJPEG ?"MJPEG":(dev->setting.fcc==V4L2_PIX_FMT_H264 ? "H264":"H265"))));

    return MI_SUCCESS;
}

static MI_S32 UVC_StopCapture(void *uvc)
{
	return MI_SUCCESS;	
}

MI_S32 ST_UvcDeinit()
{
    for (int i = 0; i < g_UvcSrc->devnum; i++)
    {
        ST_UvcDev_t *dev = &g_UvcSrc->dev[i];
        STCHECKRESULT(ST_UVC_StopDev((dev->handle)));
        STCHECKRESULT(ST_UVC_DestroyDev(dev->handle));
        STCHECKRESULT(ST_UVC_Uninit(dev->handle));
    }
    return MI_SUCCESS;
}


MI_S32 ST_UvcInitDev(ST_UvcDev_t *dev, MI_U32 maxpacket, MI_U8 mult, MI_U8 burst, MI_U8 c_intf, MI_U8 s_intf, MI_S32 mode, MI_S32 type)
{
    ST_UVC_Setting_t pstSet={g_maxbuf_cnt, maxpacket, mult, burst, c_intf, s_intf, (UVC_IO_MODE_e)mode, (Transfer_Mode_e)type};
    ST_UVC_MMAP_BufOpts_t m = {UVC_MM_FillBuffer};

    ST_UVC_OPS_t fops = { UVC_Init,
                          UVC_Deinit,
                          {{}},
                          UVC_StartCapture,
                          UVC_StopCapture,
                          UVC_ForceIdr};
    fops.m = m;

    printf(ASCII_COLOR_YELLOW "ST_UvcInitDev: name:%s bufcnt:%d mult:%d burst:%d ci:%d si:%d, Mode:%s, Type:%s" ASCII_COLOR_END "\n",
                    dev->name, g_maxbuf_cnt, mult, burst, c_intf, s_intf, mode==UVC_MEMORY_MMAP?"mmap":"userptr", type==USB_ISOC_MODE?"isoc":"bulk");

    ST_UVC_ChnAttr_t pstAttr ={pstSet,fops};
    STCHECKRESULT(ST_UVC_Init(dev->name, &dev->handle));
    STCHECKRESULT(ST_UVC_CreateDev(dev->handle, &pstAttr));
    STCHECKRESULT(ST_UVC_StartDev(dev->handle));
    return MI_SUCCESS;
}

MI_S32 ST_UvcInit(MI_S32 devnum, MI_U32 *maxpacket, MI_U8 *mult, MI_U8 *burst, MI_U8 *intf, MI_S32 mode, MI_S32 type)
{
    char devnode[20] = "/dev/video0";

    g_UvcSrc = (ST_UvcSrc_t*)malloc(sizeof(g_UvcSrc) + sizeof(ST_UvcDev_t) * devnum);
    memset(g_UvcSrc, 0x0, sizeof(g_UvcSrc) + sizeof(ST_UvcDev_t) * devnum);
    g_UvcSrc->devnum = devnum;

    for (int i = 0; i < devnum; i++)
    {
        ST_UvcDev_t *dev = &g_UvcSrc->dev[i];
        sprintf(devnode, "/dev/video%d", i);
        dev->dev_index = i;
        memcpy(dev->name, devnode, sizeof(devnode));
        ST_UvcInitDev(dev, maxpacket[i], mult[i], burst[i], intf[2*i], intf[2*i+1], mode, type);
    }
    return MI_SUCCESS;
}

void ST_DoExitProc(void *args)
{
    g_bExit = TRUE;
}

int main(int argc, char **argv)
{
    MI_U32 maxpacket[MAX_UVC_DEV_NUM] = {1024};
    MI_U8 mult[MAX_UVC_DEV_NUM] = {2},
          burst[MAX_UVC_DEV_NUM] = {13};
    MI_U8 intf[2 * MAX_UVC_DEV_NUM] = {0};
    MI_S32 mode = UVC_MEMORY_MMAP, type = USB_ISOC_MODE;
    MI_S32 trace_level = UVC_DBG_ERR;
    struct sigaction sigAction;
    sigAction.sa_handler = ST_HandleSig;
    sigemptyset(&sigAction.sa_mask);
    sigAction.sa_flags = 0;
    sigaction(SIGINT, &sigAction, NULL);

    ST_DefaultArgs(&g_stConfig);
    STCHECKRESULT(ST_Sys_Init());
    ST_UVC_SetTraceLevel(trace_level);
    ST_VideoModuleInit(&g_stConfig);
    ST_UvcInit(g_device_num, maxpacket, mult, burst, intf, mode, type);

    while(!g_bExit)
    {
        usleep(100 * 1000);
    }
    usleep(100 * 1000);

    ST_UvcDeinit();
    STCHECKRESULT(ST_VideoModuleUnInit(&g_stConfig));
    STCHECKRESULT(ST_Sys_Exit());

    return 0;
}

